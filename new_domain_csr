#!/bin/bash

mydir="$(dirname "$0")"
. ${mydir}/lib/sysexits.sh
. ${mydir}/lib/common.sh
. ${mydir}/etc/config.sh

printhelp() {
    echoerr "$0 [OPTIONS] [FQDN [FQDN [...]]]"
    echoerr ""
    echoerr "generate a new certificate signing request for given FQDN(s)"
    echoerr "if more than one fqdn are given, they will be used as"
    echoerr "subject alternative names"
    echoerr ""
    echoerr "OPTIONS:"
    echoerr "  --help display this help and exit"
    echoerr "  --all generate a csr for all domains listed in etc/domains.list"
    echoerr "        FQDNs must not be listed together with this option"
    echoerr "  "
}

parse_cmdline() {
    [[ "$#" -eq 0 ]] && {
        printhelp
        exit $EX_USAGE
    }

    while [[ $# > 0 ]]
    do
        key="$1"

        case "$key" in
            --all)
                OPT_ALL=1
                ;;
            --help)
                printhelp
                exit $EX_USAGE
                ;;
            *)
                FQDNS+=("$key")
                ;;
        esac
        shift
    done

    [[ "$OPT_ALL" -eq 1 && "${#FQDNS[@]}" -gt 0 ]] && {
        echoerr "ERROR: options --all and specifying FQDNs are mutually exclusive"
        exit $EX_USAGE
    }

    [[ "$OPT_ALL" -eq 0 && "${#FQDNS[@]}" -lt 1 ]] && {
        echoerr "ERROR: no domainnames given: ${#FQDNS[@]}"
        exit $EX_USAGE
    }
}

# process global array FQDNS
process_fqdns() {
    # ignore empty array
    [[ "${#FQDNS}" -gt 0 ]] || {
        return
    }

    fqdn_cn="${FQDNS[0]}"
    filename="$(date +%Y-%m-%d)_letsencrypt_${fqdn_cn}"

    [[ -r "private/${filename}_key.pem" ]] || {
        echoerr "ERROR: could not read private/${filename}_key.pem"
        echoerr "maybe call '${mydir}/new_domain_key ${fqdn_cn}' first?"
        exit $EX_NOINPUT
    }

    if [[ "${#FQDNS[@]}" -eq 1 ]];
    then
        # generate certificate with one CN and no SAN
        openssl req -text \
            -new -sha256 \
            -out "${certsdir}/${filename}_csr.pem" \
            -key "${keysdir}/${filename}_key.pem" \
            -config <(cat "$opensslconfig" - <<EOF
[req_distinguished_name]
    CN = ${fqdn_cn}
EOF
    )
    else
        # generate certificate with all fqdns in SAN
        fqdn_san="$(echo "DNS:${FQDNS[@]}" | sed -re 's/ /,DNS:/g')"

        # set first domain as CN for compatibility
        openssl req -text \
            -new -sha256 \
            -out "${certsdir}/${filename}_csr.pem" \
            -key "${keysdir}/${filename}_key.pem" \
            -multivalue-rdn \
            -subj "/CN=${fqdn_cn}" \
            -reqexts SAN \
            -config <(cat "$opensslconfig" - <<EOF
[req_distinguished_name]
    CN = ${fqdn_cn}
[SAN]
    subjectAltName = $fqdn_san
EOF
    )
    fi
} # end of procedure "process_fqdns"


OPT_ALL=0
FQDNS=()

parse_cmdline "$@"

if [[ "$OPT_ALL" -eq 1 ]];
then
    [[ -r "${etcdir}/domains.list" ]] || {
        echoerr "ERROR: cannot read ${etcdir}/domains.list"
        exit $EX_NOINPUT
    }

    while read line; do
        # Note: domains.list allows only domainnames without spaces, thus
        # don't use quotes around $line here
        FQDNS=($line)
        process_fqdns
    done <"${etcdir}/domains.list"
else
    # Note: FQDNS already set by process_cmdline
    process_fqdns
fi

exit $EX_OK
