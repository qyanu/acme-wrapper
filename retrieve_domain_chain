#!/bin/bash

##-- section that should go to config file
RETRIEVE_COOLDOWN=2592000 # seconds: 30 days
##-- end of config section


mydir="$(dirname "$0")"
keysdir="${mydir}/private"
certsdir="${mydir}/public"
cadir="${mydir}/authority"
etcdir="${mydir}/etc"
opensslconfig="${etcdir}/openssl.cnf"

# see sysexits.h
EX_OK=0
EX_USAGE=64
EX_NOINPUT=66
EX_UNAVAILABLE=69

echoerr() {
    echo "[$$]" "$@" >&2
}

echolog() {
    echo "[$$]" "$@"
}

printhelp() {
    echoerr "$0 [OPTIONS] [FQDN [FQDN [...]]]"
    echoerr ""
    echoerr "inspects the most recently retrieved certificate for the"
    echoerr "specified FQDNs, and retrieves their full chain (where possible)."
    echoerr "stores the combined chain into a crt+bundle file beside the"
    echoerr "original certificate."
    echoerr ""
    echoerr "OPTIONS:"
    echoerr "  --help display this help and exit"
    echoerr "  --all retriebe chain for all domains listed in etc/domains.list"
    echoerr "        FQDNs must not be listed together with this option"
    echoerr "  "
}

parse_cmdline() {
    [[ "$#" -eq 0 ]] && {
        printhelp
        exit $EX_USAGE
    }

    while [[ $# > 0 ]]
    do
        key="$1"

        case "$key" in
            --all)
                OPT_ALL=1
                ;;
            --help)
                printhelp
                exit $EX_USAGE
                ;;
            *)
                FQDNS+=("$key")
                ;;
        esac
        shift
    done

    [[ "$OPT_ALL" -eq 1 && "${#FQDNS[@]}" -gt 0 ]] && {
        echoerr "ERROR: options --all and specifying FQDNs are mutually exclusive"
        exit $EX_USAGE
    }

    [[ "$OPT_ALL" -eq 0 && "${#FQDNS[@]}" -lt 1 ]] && {
        echoerr "ERROR: no domainnames given: ${#FQDNS[@]}"
        exit $EX_USAGE
    }
}


# process global array FQDNS
process_fqdns() {
    # ignore empty array
    [[ "${#FQDNS}" -gt 0 ]] || {
        return
    }

    fqdn_cn="${FQDNS[0]}"
    filepath="$(compgen -G "${certsdir}/*_letsencrypt_${fqdn_cn}_crt.pem" \
        | sort --reverse | head -n1)"

    [[ -f "${filepath}" ]] || {
        echoerr "ERROR: no certificate file found for '${fqdn_cn}'"
        exit $EX_NOINPUT
    }
    [[ -r "${filepath}" ]] || {
        echoerr "ERROR: permission denied for '${filepath}'"
        exit $EX_NOINPUT
    }

    pivottime=$(( $(date +%s) - RETRIEVE_COOLDOWN ))

    # retrieve issuer intermediate certificate if not recently retrieved
    issuer_uri="$(
        openssl x509 -in "${filepath}" -noout -text \
            | sed -n -re '/ +CA Issuers - URI:/s/[^:]*://p'
    )"
    issuer_filename="$(echo "$issuer_uri" | sed -re 's/\//_/g')"
    [[ ! -r "${cadir}/${issuer_filename}.der"
    || $(date -r "${cadir}/${issuer_filename}.der" +%s ) -lt $pivottime
    ]] && {
        tmpfile=$(mktemp)
        curl -s "${issuer_uri}" > "${tmpfile}"

        if [[ "$?" -eq 0 ]]; then
            mv "${tmpfile}" "${cadir}/${issuer_filename}.der"
        else
            rm "$tmpfile"
            echoerr "ERROR: could not download issuer certificate from \
                '${issuer_uri}'"
            exit $EX_UNAVAILABLE
        fi

        openssl x509 \
            -inform DER -in "${cadir}/${issuer_filename}.der" \
            -text > "${cadir}/${issuer_filename}.pem"
    }

    [[ -r "${cadir}/${issuer_filename}.pem" ]] || {
        echoerr "ERROR: cannot read file '${cadir}/${issuer_filename}.pem'"
        exit $EX_NOINPUT
    }

    # also retrieve root ca certificate
    rootcrt_uri="$(
        openssl x509 -in "${cadir}/${issuer_filename}.pem" -noout -text \
            | sed -n -re '/ +CA Issuers - URI:/s/[^:]*://p'
    )"
    rootcrt_filename="$(echo "$rootcrt_uri" | sed -re 's/\//_/g')"
    [[ ! -r "${cadir}/${rootcrt_filename}"
    || $(date -r "${cadir}/${rootcrt_filename}" +%s ) -lt $pivottime
    ]] && {
        tmpfile=$(mktemp)
        curl -s "${rootcrt_uri}" > "${tmpfile}"

        if [[ "$?" -eq 0 ]]; then
            mv "${tmpfile}" "${cadir}/${rootcrt_filename}"
        else
            rm "$tmpfile"
            echoerr "ERROR: could not download issuer certificate from \
                '${rootcrt_uri}'"
            exit $EX_UNAVAILABLE
        fi

        openssl pkcs7 -inform DER -in "${cadir}/${rootcrt_filename}" \
            -print_certs -text > "${cadir}/${rootcrt_filename}.pem"
    }


    # create bundle file of domain certificate
    filepathbundle="$(sed -re 's/crt/crt+bundle/' <<<"$filepath")"
    cat "${filepath}" \
        "${cadir}/${issuer_filename}.pem" \
        > "${filepathbundle}"

    c_rehash "${cadir}" 2> /dev/null >/dev/null

    # verify the certificate
    openssl verify -CApath "${cadir}" \
        "${filepath}"
    [[ "$?" -eq 0 ]] || {
        echoerr "ERROR: the issued certificate '${filepath}'"
        echoerr "was not accepted as valid by this system"
        exit $EX_UNAVAILABLE
    }

    openssl verify -CApath "${cadir}" \
        "${filepathbundle}"
    [[ "$?" -eq 0 ]] || {
        echoerr "ERROR: the issued certificate '${filepathbundle}'"
        echoerr "was not accepted as valid by this system"
        exit $EX_UNAVAILABLE
    }

} # end of procedure "process_fqdns"


OPT_ALL=0
FQDNS=()

parse_cmdline "$@"

if [[ "$OPT_ALL" -eq 1 ]];
then
    [[ -r "${etcdir}/domains.list" ]] || {
        echoerr "ERROR: cannot read ${etcdir}/domains.list"
        exit $EX_NOINPUT
    }

    while read line; do
        # Note: domains.list allows only domainnames without spaces, thus
        # don't use quotes around $line here
        FQDNS=($line)
        process_fqdns
    done <"${etcdir}/domains.list"
else
    # Note: FQDNS already set by process_cmdline
    process_fqdns
fi

exit $EX_OK
