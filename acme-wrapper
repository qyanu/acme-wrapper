#!/bin/bash
set -u


########################
#### self-awareness ####

mydir="$(dirname "$0")"
acme_tiny="${mydir}/acme-tiny/acme_tiny.py"
etcdir="${mydir}/etc"
libdir="${mydir}/lib"
keysdir="${mydir}/private"
certsdir="${mydir}/public"
cadir="${mydir}/authority"
accountdir="${mydir}/account"
opensslconfig="${libdir}/openssl.cnf"


###########################
#### get configuration ####

[[ -r "${etcdir}/letsencrypt-wrapper.conf" ]] && {
    . "${etcdir}/letsencrypt-wrapper.conf"
}


################################
#### codes reserved by bash ####
EX_OK=0
EX_GENERAL_ERROR=1
EX_MISUSE_OF_BUILTIN=2
# gap from 3 to 125
EX_COMMAND_CANNOT_EXEC=126
EX_COMMAND_NOT_FOUND=127
EX_INVALID=128
EX_SIGNAL_1=129
EX_SIGNAL_2=130
EX_SIGNAL_INT=130
EX_SIGNAL_9=137
EX_SIGNAL_KILL=137
EX_SIGNAL_15=143
EX_SIGNAL_TERM=143
# gap from 166 to 254
EX_OUT_OF_RANGE=255

###############################
#### codes from sysexits.h ####
EX_OK=0
# gap from 1 to 63
EX_BASE=64
EX_USAGE=64
EX_NOINPUT=66
EX_UNAVAILABLE=69
EX_CONFIG=78
# gap from 78 to 255

###############################
#### my custom exit codes ####
EX_OK=0
# use range 16 to 32 for errors:



echoerr() {
    echo "[$$]" "$@" >&2
}

echolog() {
    echo "[$$]" "$@"
}

printhelp() {
    echoerr "$0 [COMMAND] [OPTIONS] [FQDN] [SANs]"
    echoerr ""
    echoerr "wrapper around acme-tiny intended to be automatically executed"
    echoerr "by cron et al"
    echoerr ""
    echoerr "COMMAND:"
    echoerr ""
    echoerr "  Unless otherwise noted, each command might succeed or fail but"
    echoerr "  does not leave intermediate state"
    echoerr ""
    echoerr "  --help  display this help and exit"
    echoerr ""
    echoerr "  --fsck  perform selfcheck on own data"
    echoerr ""
    echoerr "  --account-create  generate a new rsa key-pair used as"
    echoerr "      letsencrypt account"
    echoerr ""
    echoerr "  --domain-new-key  create a new rsa keypair named after the"
    echoerr "      first FQDNS (SANs are ignored)"
    echoerr ""
    echoerr "  --domain-new-csr  create a new certificate signing request for"
    echoerr "      given FQDN(s) if more than one fqdn are given, subject"
    echoerr "      alternative names will be used accordingly"
    echoerr ""
    echoerr "  --domain-submit-csr  submit the csr in order to receive a (new)"
    echoerr "      certificate with CN set to the first fqdn and all fqdns"
    echoerr "      set as SAN (if there are more than one fqdn)"
    echoerr ""
    echoerr "      Daniel Roesler's acme-tiny <https://github.com/diafygi/acme-tiny>"
    echoerr "      is used to communicate with the letsencrypt server"
    echoerr ""
    echoerr "      challenges are placed into the ACME_CHALLENGE_DIR directory"
    echoerr "      which must be available to the letsencrypt server via HTTP(s)"
    echoerr "      at the appropriate URLs"
    echoerr ""
    echoerr "  --chain-retrieve  inspect the current certificate for given fqdn"
    echoerr "      and retrieve the certificates up the chain, as referenced"
    echoerr "      inside the certificate."
    echoerr "      will create a crt+bundle file beside the certificate."
    echoerr ""
    echoerr "  --automatic-upkeep  do everything to in order to get a generic"
    echoerr "      certificate; usually combined with the --all options and"
    echoerr "      called from cron."
    echoerr "      - for each FQDN (in case of '--all', for each line in "
    echoerr "        etc/domains.list):"
    echoerr "        - create account key if not yet created"
    echoerr "        - if no certificate exists or newest existing certificate"
    echoerr "          is expired or will expire within RESUBMIT_BEFORE"
    echoerr "          seconds:"
    echoerr "          - create domain key"
    echoerr "          - create domain csr"
    echoerr "          - submit domain csr (via acme-tiny client)"
    echoerr "          - try to have a full chain of certificates for that new"
    echoerr "            domain crt, possibly downloading issuer certificates"
    echoerr "            (also creates crt+bundle file)"
    echoerr ""
    echoerr "OPTIONS:"
    echoerr ""
    echoerr "  --all  all lines from etc/domains.list are interpreted each as"
    echoerr "      FQDNs with optional additional SANs. the specified command"
    echoerr "      will be executed for each line. Each line is executed as"
    echoerr "      seperate operation which might succeed or fail but does"
    echoerr "      not leave intermediate states."
    echoerr ""
    echoerr "FQDN:"
    echoerr ""
    echoerr "  the first non-option parameter is the fully qualified domain name"
    echoerr "  of the certificate to be processed by the command"
    echoerr ""
    echoerr "SAN(s):"
    echoerr ""
    echoerr "  all other non-option parameters are additional fqdns for the same"
    echoerr "  certificate, used as subject-alternative-name(s)"
    echoerr ""
}

parse_cmdline() {
    [[ "$#" -eq 0 ]] && {
        printhelp
        return $EX_USAGE
    }

    OPT_ALL=0
    FQDNS=()

    while [[ $# > 0 ]]
    do
        key="$1"

        case "$key" in
            # commands
            --help)
                printhelp
                return $EX_USAGE
                ;;
            --fsck)
                CMD="fsck"
                ;;
            --account-create|\
            --account_create)
                CMD="account_create"
                ;;
            --domain-new-key|\
            --domain_new_key)
                CMD="domain_new_key"
                ;;
            --domain-new-csr|\
            --domain_new_csr)
                CMD="domain_new_csr"
                ;;
            --domain-submit-csr|\
            --domain_submit_csr)
                CMD="domain_submit_csr"
                ;;
            --chain-retrieve|\
            --chain_retrieve)
                CMD="chain_retrieve"
                ;;

            --automatic-upkeep|\
            --automatic_upkeep)
                CMD="automatic_upkeep"
                ;;

            # options
            --all)
                OPT_ALL=1
                ;;

            # FQDNs (including SANs)
            *)
                FQDNS+=("$key")
                ;;
        esac
        shift
    done

    [[ "$OPT_ALL" -eq 1 && "${#FQDNS[@]}" -gt 0 ]] && {
        echoerr "ERROR: option --all and specifying FQDNs are mutually exclusive"
        return $EX_USAGE
    }

    return $EX_OK
}

datestring() {
    echo "$(date +%Y-%m-%d-%H-%M-%S)"
}

fsck() {
    return $EX_OK
}

account_create() {
    [[ "${#FQDNS[@]}" -gt 0 ]] && {
        echoerr "INFO: ignoring specified fqdns, the same account rsa keypair"
        echoerr "is used for all remote operations"
    }

    # ask if account.key should be overwritten
    [[ -e "${accountdir}/current" ]] && {
        echoerr "WARN: private key file already exists: ${accountdir}/current"
        read -p "Overwrite? [y|n] " yesno
        [[ "$yesno" != "y" ]] && {
            echoerr "aborting."
            return $EX_NOINPUT
        }
    }

    commit=1

    # make new directory in order to be able to roll back
    datestr="$(datestring)"
    mkdir -p "${accountdir}/${datestr}"
    [[ "$?" -ne 0 ]] && commit=0;

    keyfile="${accountdir}/${datestr}/account_key.pem"
    pubfile="${accountdir}/${datestr}/account_pub.pem"

    linktarget="${datestr}"
    linkfile="${accountdir}/current"

    echolog "INFO: Generating RSA keypair, ${RSA_KEY_BITS} bit long modulus"
    openssl genpkey -algorithm RSA \
        -pkeyopt rsa_keygen_bits:"$RSA_KEY_BITS" \
        -out "${keyfile}" -outform PEM -text 2>/dev/null
    [[ "$?" -ne 0 ]] && commit=0;

    openssl rsa -in "${keyfile}" -check -noout 
    [[ "$?" -ne 0 ]] && commit=0;

    openssl rsa -in "${keyfile}" -pubout -text > "${pubfile}"
    [[ "$?" -ne 0 ]] && commit=0;

    # commit transaction if no error
    if [[ "$commit" -eq 1 ]]; then
        echoerr "DEBUG: commit work"
        ln -snf "${linktarget}" "${linkfile}"
    else
        echoerr "ERROR: rollback work, previous state retained"
        return $EX_UNAVAILABLE
    fi
}

domain_new_key() {
    [[ "${#FQDNS[@]}" -lt 1 ]] && {
        echoerr "ERROR: no domainnames given: ${#FQDNS[@]}"
        return $EX_USAGE
    }
    [[ "${#FQDNS[@]}" -gt 1 ]] && {
        echoerr "INFO: ignoring all SANs, only using ${FQDN[0]}"
    }

    # ignore all but the first fqdn
    fqdn_cn="${FQDNS[0]}"
    datestr="$(datestring)"
    filename="letsencrypt_${fqdn_cn}"
    keyfile="${keysdir}/${datestr}_${filename}_key.pem"
    linktarget="${datestr}_${filename}_key.pem"
    linkfile="${keysdir}/${filename}_key.pem"

    commit=1

    openssl genpkey -algorithm RSA \
        -pkeyopt rsa_keygen_bits:"$RSA_KEY_BITS" \
        -out "${keyfile}" -outform PEM -text 2>/dev/null
    [[ "$?" -ne 0 ]] && commit=0;

    chmod g+r "${keyfile}"
    [[ "$?" -ne 0 ]] && commit=0;

    # commit transaction if no error
    if [[ "$commit" -eq 1 ]]; then
        echoerr "DEBUG: commit work"
        ln -snf "${linktarget}" "${linkfile}"
    else
        echoerr "ERROR: rollback work, previous state retained"
        return $EX_UNAVAILABLE
    fi
}

domain_new_csr() {
    [[ "${#FQDNS[@]}" -lt 1 ]] && {
        echoerr "ERROR: no domainnames given: ${#FQDNS[@]}"
        return $EX_USAGE
    }

    datestr="$(datestring)"
    fqdn_cn="${FQDNS[0]}"
    filename="letsencrypt_${fqdn_cn}"
    # files read
    keyfile="${keysdir}/${filename}_key.pem"
    # files written
    csrfile="${certsdir}/${datestr}_${filename}_csr.pem"
    # written only if transaction-commit
    linkfile="${certsdir}/${filename}_csr.pem"
    linktarget="${datestr}_${filename}_csr.pem"

    [[ -r "${keyfile}" ]] || {
        echoerr "ERROR: could not read ${keyfile}"
        echoerr "maybe call '$0 --domain-new-key ${fqdn_cn}' first?"
        return $EX_NOINPUT
    }

    commit=1

    if [[ "${#FQDNS[@]}" -eq 1 ]];
    then
        # generate certificate with one CN and no SAN
        openssl req -text \
            -new -sha256 \
            -out "${csrfile}" \
            -key "${keyfile}" \
            -config <(cat "$opensslconfig" - <<EOF
[req_distinguished_name]
    CN = ${fqdn_cn}
EOF
    )
        [[ "$?" -ne 0 ]] && commit=0;
    else
        # generate certificate with all fqdns in SAN
        fqdn_san="$(echo "DNS:${FQDNS[@]}" | sed -re 's/ /,DNS:/g')"

        # set first domain as CN for compatibility
        openssl req -text \
            -new -sha256 \
            -out "${csrfile}" \
            -key "${keyfile}" \
            -multivalue-rdn \
            -subj "/CN=${fqdn_cn}" \
            -reqexts SAN \
            -config <(cat "$opensslconfig" - <<EOF
[req_distinguished_name]
    CN = ${fqdn_cn}
[SAN]
    subjectAltName = $fqdn_san
EOF
    )
        [[ "$?" -ne 0 ]] && commit=0;
    fi

    chmod g+r "${csrfile}"
    [[ "$?" -ne 0 ]] && commit=0;

    # commit transaction if no error
    if [[ "$commit" -eq 1 ]]; then
        echoerr "DEBUG: commit work"
        ln -snf "${linktarget}" "${linkfile}"
    else
        echoerr "ERROR: rollback work, previous state retained"
        return $EX_UNAVAILABLE
    fi
}

domain_submit_csr() {
    [[ "${#FQDNS[@]}" -lt 1 ]] && {
        echoerr "ERROR: no domainnames given: ${#FQDNS[@]}"
        return $EX_USAGE
    }

    datestr="$(datestring)"
    fqdn_cn="${FQDNS[0]}"
    filename="letsencrypt_${fqdn_cn}"
    # files read
    accountkeyfile="${accountdir}/current/account_key.pem"
    keyfile="${keysdir}/${filename}_key.pem"
    csrfile="${certsdir}/${filename}_csr.pem"
    # files written
    crtfile="${certsdir}/${datestr}_${filename}_crt.pem"
    # written only if transaction-commit
    linkfile="${certsdir}/${filename}_crt.pem"
    linktarget="${datestr}_${filename}_crt.pem"

    commit=1

    tmpcrt="$(mktemp)"
    prevumask="$(umask)"
    umask 022
    python "${acme_tiny}" \
        --account-key "${accountkeyfile}" \
        --csr "${csrfile}" \
        --acme-dir "${ACME_CHALLENGE_DIR}" \
    > "${tmpcrt}"
    [[ "$?" -ne 0 ]] && {
        echoerr "ERROR: could not get signed certificate from letsencrypt"
        commit=0;
    }
    umask "$prevumask"

    # verify that certificate matches private key
    ## if produces more than 1 line, fingerprints mismatch and thus
    ## public key parts are different
    [[ "${commit}" -eq 1 && "$(
        (openssl x509 -noout -modulus -in "${tmpcrt}" | openssl md5 ;\
         openssl rsa -noout -modulus -in "${keyfile}" | openssl md5) \
         | uniq | wc -l)" -ne 1 ]] &&
    {
        echoerr "ERROR: received certificate does not match private key"
        commit=0
    }

    [[ "$commit" -eq 1 ]] && {
        openssl x509 -in "${tmpcrt}" -text > "${crtfile}"
        [[ "$?" -ne 0 ]] && commit=0;
    }

    rm -f "${tmpcrt}"
    [[ "$?" -ne 0 ]] && {
        echoerr "WARN: could not remove temporary file: ${tmpcrt}"
    }

    [[ -e "${crtfile}" ]] && {
        chmod g+r "${crtfile}"
        [[ "$?" -ne 0 ]] && commit=0;
    }

    # only commit work if no error
    if [[ "${commit}" -eq 1 ]]; then
        ln -snf "${linktarget}" "${linkfile}"
    else
        echoerr "ERROR: rollback work, previous state retained"
        return $EX_UNAVAILABLE
    fi
}

chain_retrieve() {
    [[ "${#FQDNS[@]}" -lt 1 ]] && {
        echoerr "ERROR: no domainnames given: ${#FQDNS[@]}"
        return $EX_USAGE
    }
    [[ "${#FQDNS[@]}" -gt 1 ]] && {
        echoerr "INFO: ignoring all SANs, only using ${FQDN[0]}"
    }

    datestr="$(datestring)"
    fqdn_cn="${FQDNS[0]}"
    filename="letsencrypt_${fqdn_cn}"
    pivottime=$(( $(date +%s) - RETRIEVE_COOLDOWN ))
    # files read
    keyfile="${keysdir}/${filename}_key.pem"
    csrfile="${certsdir}/${filename}_csr.pem"
    crtfile="${certsdir}/${filename}_crt.pem"
    # files written
    bundlefile="${certsdir}/${datestr}_${filename}_crt+bundle.pem"
    # written only if transaction-commit
    linkfile="${certsdir}/${filename}_crt+bundle.pem"
    linktarget="${datestr}_${filename}_crt+bundle.pem"

    [[ -f "${crtfile}" ]] || {
        echoerr "ERROR: no certificate file found for '${fqdn_cn}'"
        return $EX_NOINPUT
    }

    # create temporary file for crt+bundle, but delete immediately
    # in order to ensure cleanedup state in case of error
    bundletmpfd="$(mktemp)"
    exec 4<> "${bundletmpfd}"
    rm -f "${bundletmpfd}"
    bundletmpfd="/proc/$$/fd/4"

    currentcertfile="${certsdir}/$(readlink ${crtfile})"
    while true; do
        # determine issuer certificate uri and filename
        issuer_uri="$(
            openssl x509 -in "${currentcertfile}" -noout -text \
                | sed -n -re '/ +CA Issuers - URI:/s/[^:]*://p'
        )"
        issuer_file="${cadir}/$(echo "$issuer_uri" | sed -re 's/\//_/g')"

        # check if no issuer certificate => we have reached root
        [[ "${issuer_uri}" = "" ]] && {
            break
        }

        # otherwise append the previous certificate to the crt+bundle
        # because the final root certitificate should be inside of crt+bundle
        # the first certificate added here will be the leaf
        cat "${currentcertfile}" >> "${bundletmpfd}"

        # retrieve issuer cert if not exists or not recently retrieved
        [[ ! -r "${issuer_file}.pem"
        || $(date -r "${issuer_file}.pem" +%s ) -lt $pivottime
        ]] && {
            tmpfile=$(mktemp)
            curl -s "${issuer_uri}" > "${tmpfile}"

            if [[ "$?" -eq 0 ]]; then
                mv "${tmpfile}" "${issuer_file}"
                chmod g+r "${issuer_file}"
            else
                rm -f "$tmpfile"
                echoerr "ERROR: could not download issuer certificate from \
                    '${issuer_uri}'"
                return $EX_UNAVAILABLE
            fi

            # Note: the downloaded file might be PEM or DER encoded, and might
            # provide the certificate in a x509 or pkcs7 container format

            converted=0
            tmpfile=$(mktemp)

            # convert if x509 with DER:
            [[ converted -eq 0 ]] && \
            openssl x509 \
                -inform DER -in "${issuer_file}" \
                -text > "${tmpfile}" 2>/dev/null
            [[ "$?" -eq 0 ]] && {
                # it did work, use result
                mv "${tmpfile}" "${issuer_file}.pem"
                converted=1
            }
            # else try next
            rm -f "${tmpfile}"

            # convert if pkcs7 with DER:
            [[ converted -eq 0 ]] && \
            openssl pkcs7 -inform DER -in "${issuer_file}" \
                -print_certs -text > "${tmpfile}" 2>/dev/null
            [[ "$?" -eq 0 ]] && {
                mv "${tmpfile}" "${issuer_file}.pem"
                converted=1
            }
            # else try next
            rm -f "${tmpfile}"

            [[ -e "${issuer_file}.pem" ]] && {
                chmod g+r "${issuer_file}.pem"
            }

            # no conversion method left, give up
            [[ converted -eq 0 ]] && {
                echoerr "ERROR: could not convert downloaded file into x509 PEM: ${issuer_uri}"
                return $EX_UNAVAILABLE
            }
        }

        currentcertfile="${issuer_file}.pem"
    done

    # rehash authority certificates after download
    c_rehash "${cadir}" 2> /dev/null >/dev/null

    # verify the certificate
    openssl verify -CApath "${cadir}" "${crtfile}"
    [[ "$?" -eq 0 ]] || {
        echoerr "ERROR: the issued certificate '${crtfile}'"
        echoerr "was not accepted as valid by this system"
        return $EX_UNAVAILABLE
    }

    openssl verify -CApath "${cadir}" "${bundletmpfd}"
    [[ "$?" -eq 0 ]] || {
        echoerr "ERROR: the newly created certificate bundle"
        echoerr "was not accepted as valid by this system"
        return $EX_UNAVAILABLE
    }

    # no errors, so store crt+bundle in proper filename
    cat "${bundletmpfd}" > "${bundlefile}"
    chmod g+r "${bundlefile}"
    # plus create symlink
    ln -snf "${linktarget}" "${linkfile}"

    return $EX_OK
}

automatic_upkeep() {
    [[ "${#FQDNS[@]}" -lt 1 ]] && {
        echoerr "ERROR: no domainnames given: ${#FQDNS[@]}"
        return $EX_USAGE
    }

    # save original FQDNS, because we only pass some parts of it
    # to sub-command in order to avoid warnings about ignored FQDNs/SANs
    local orig_FQDNS=("${FQDNS[@]}")

    # common files and paths
    datestr="$(datestring)"
    fqdn_cn="${FQDNS[0]}"
    filename="letsencrypt_${fqdn_cn}"
    # symlinks to current files
    keyfile="${keysdir}/${filename}_key.pem"
    csrfile="${certsdir}/${filename}_csr.pem"
    crtfile="${certsdir}/${filename}_crt.pem"
    bundlefile="${certsdir}/${filename}_crt+bundle.pem"

    # remember old symlink targets for rollback
    local keylinktarget="$(readlink "${keyfile}")"
    local csrlinktarget="$(readlink "${csrfile}")"
    local crtlinktarget="$(readlink "${crtfile}")"
    local bundlelinktarget="$(readlink "${bundlefile}")"

    # 1. create account key if missing
    FQDNS=()
    [[ -f "${accountdir}/current/account_key.pem" ]] || {
        # create new account key
        account_create
        [[ "$?" -ne 0 ]] && {
            echoerr "ERROR: could not create account key"
            return $EX_UNAVAILABLE
        }
    }

    # 2. check if certificate does not exist or is expiring shortly
    FQDNS=("${orig_FQDNS[@]}")
    echolog "CHECK ${FQDNS[@]}"

    need_new_key_and_crt=0

    if [[ -e "${crtfile}" ]];
    then # exists but is old
        openssl x509 -checkend "${RESUBMIT_BEFORE}" -in "${crtfile}"
        [[ "$?" -eq 0 ]] || {
            echolog "EXPIRING (will cause CREATE): ${crtfile}"
            need_new_key_and_crt=1
        }
    else # does not exit
        echolog "NOTFOUND (will cause CREATE): ${crtfile}"
        need_new_key_and_crt=1
    fi

    # if we need new certificate
    [[ "${need_new_key_and_crt}" -eq 1 ]] && {
        commit=1

        # generate new key
        [[ "${commit}" -eq 1 ]] && {
            echolog "NEWKEY: ${FQDNS[@]}"
            FQDNS=("${fqdn_cn}")
            domain_new_key
            r="$?"
            FQDNS=("${orig_FQDNS}")
            [[ "$r" -ne 0 ]] && {
                echoerr "ERROR: could not create new domain key"
                commit=0
            }
        }

        # generate csr for key
        [[ "${commit}" -eq 1 ]] && {
            echolog "NEWCSR: ${FQDNS[@]}"
            domain_new_csr
            [[ "$?" -ne 0 ]] && {
                echoerr "ERROR: could not create new domain csr"
                commit=0
            }
        }

        # submit csr and retrieve crt
        [[ "${commit}" -eq 1 ]] && {
            echolog "REQCRT: ${FQDNS[@]}"
            domain_submit_csr
            [[ "$?" -ne 0 ]] && {
                echoerr "ERROR: could not retrieve new domain crt"
                commit=0
            }
        }

        # get issuer and root cert, create bundle
        [[ "${commit}" -eq 1 ]] && {
            echolog "BUNDLE: ${FQDNS[@]}"
            chain_retrieve
            [[ "$?" -ne 0 ]] && {
                echoerr "ERROR: could not create bundle"
                commit=0
            }
        }

        # revert changes if something went wrong
        [[ "${commit}" -ne 1 ]] && {
            # revert symlink of key
            [[ -n "${keylinktarget}" ]] &&
                ln -snf "${keylinktarget}" "${keyfile}"
            # revert symlink of csr
            [[ -n "${csrlinktarget}" ]] &&
                ln -snf "${csrlinktarget}" "${csrfile}"
            # revert symlink of crt
            [[ -n "${crtlinktarget}" ]] &&
                ln -snf "${crtlinktarget}" "${crtfile}"
            # revert symlink of bundle
            [[ -n "${bundlelinktarget}" ]] &&
                ln -snf "${bundlelinktarget}" "${bundlefile}"
            return $EX_UNAVAILABLE
        }

        return $EX_OK
    }
}

main() {
    # if OPT_ALL, read all lines from etc/domains.list into $FQDNS[]
    if [[ "$OPT_ALL" -eq 1 ]];
    then
        [[ -r "${etcdir}/domains.list" ]] || {
            echoerr "ERROR: cannot read ${etcdir}/domains.list"
            return $EX_NOINPUT
        }

        while read line; do
            # skip comments
            [[ "$line" =~ ^\ *# ]] && continue;
            # skip empty lines
            [[ "$line" =~ ^\ *$ ]] && continue;
            # expand the line into fqdns
            # it's simple, because each line is a space-seperated list of
            # fqdns
            FQDNS=($line)
            # execute command in subshell
            "$0" "--${CMD}" "${FQDNS[@]}"
        done <"${etcdir}/domains.list"
    else
        # FQDNS already expanded/set by parse_cmdline
        # execute command
        $CMD
    fi
}

umask 0077
parse_cmdline "$@" && \
main
